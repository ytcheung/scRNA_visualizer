---
title: "Cow RNA"
output: html_document
---
```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = FALSE)
```
A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5112579/

Orchestrating Single-Cell Analysis with Bioconductor: Workshop
http://biocworkshops2019.bioconductor.org.s3-website-us-east-1.amazonaws.com/page/OSCABioc2019__OSCABioc2019/
https://osca.bioconductor.org/quality-control.html#choice-of-qc-metrics
https://bioconductor.org/packages/devel/bioc/vignettes/scran/inst/doc/scran.html

Seurat Tutorial:
https://scrnaseq-course.cog.sanger.ac.uk/website/seurat-chapter.html#setup-the-seurat-object
https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html
https://learn.gencore.bio.nyu.edu/single-cell-rnaseq/
https://broadinstitute.github.io/2019_scWorkshop/data-wrangling-scrnaseq.html
https://nbisweden.github.io/excelerate-scRNAseq/session-qc/Quality_control.html



Current best practices in single‐cell RNA‐seq analysis: a tutorial
https://www.embopress.org/doi/10.15252/msb.20188746

A systematic evaluation of single cell RNA-seq analysis pipelines
https://www.nature.com/articles/s41467-019-12266-7

Single-cell RNA sequencing technologies and bioinformatics pipelines
https://www.nature.com/articles/s12276-018-0071-8#Sec3

Normalizing single-cell RNA sequencing data: challenges and opportunities
https://www.nature.com/articles/nmeth.4292


## Setup
Load required packages
```{r main, message=FALSE}
suppressMessages(require(Seurat))
#suppressMessages(require(cowplot))
suppressMessages(require(scater))
#suppressMessages(require(igraph))
```

Read data
```{r}
cow.matrix <- read.table(file="./data/rawCounts.txt", na.strings = "-", sep = "\t", header = TRUE)
cow.metadata <- read.table(file="./data/annotation.txt", na.strings = "-", sep = "\t", header = TRUE)
cow.gene_name <- read.table(file="./data/geneInfo.txt", na.strings = "-", sep = "\t", header = TRUE)
```

```{r, include=FALSE, eval=FALSE}
# temp <- cbind(geneName = cow.gene_name$Gene.Name[ match(rownames(cow.matrix), cow.gene_name$Gene.ID) ], cow.matrix)
# temp$geneName[is.na(temp$geneName)] <- rownames(temp[is.na(temp$geneName),])

# row.names(temp) <- temp$geneName


rownames(sce) <- rowData(sce)$Symbol_TENx

## counts dupes from top to bottom
dupes <- duplicated(rownames(sce))

## keep all the not (!) duplicated genes
sce <- sce[!dupes, ]
```

Create the Seruat object
```{r}
# Keep all genes expressed in >= 3 cells
cow <- CreateSeuratObject(counts = cow.matrix, meta.data = cow.metadata, min.cells = 3)
```


## Quality Control
Calculate mitochondrial proportion and ribosomal proportion
```{r}
mt.genes <- cow.gene_name$Gene.ID[grep("^MT-",cow.gene_name$Gene.Name)]
percent.mito <- Matrix::colSums(cow[mt.genes, ])/Matrix::colSums(cow) * 100
cow <- AddMetaData(cow, percent.mito, col.name = "percent.mito")

rb.genes <- cow.gene_name$Gene.ID[grep("^RP[SL]",cow.gene_name$Gene.Name)]
percent.ribo <- Matrix::colSums(cow[rb.genes, ])/Matrix::colSums(cow) * 100
cow <- AddMetaData(cow, percent.ribo, col.name = "percent.ribo")
```

Create the Single Cell Experiment object
```{r}
sce <- as.SingleCellExperiment(cow)
sce <- addPerCellQC(sce, subsets = list(mito = mt.genes))
sce <- addPerFeatureQC(sce)
```

### Plot QC {.tabset}
#### Histograms
```{r}
hist(sce$total/1e6, xlab="Library sizes(millions)", main="",breaks=50, col="grey80", ylab="Number of cells")
hist(sce$detected, xlab="Number of expressed genes", main="",breaks=50, col="grey80", ylab="Number of cells")
hist(sce$subsets_mito_percent, xlab="Mito %", main="",breaks=50, col="grey80", ylab="Number of cells")
```

#### QC 
More than 3 MADs = Outlier
```{r}
#libsize.drop <- isOutlier(sce$total, nmads=3, type="lower", log=TRUE)
#feature.drop <- isOutlier(sce$detected, nmads=3, type="lower", log=TRUE)
#mito.drop <- isOutlier(sce$subsets_mito_percent, nmads=3, type="higher")

#attr(libsize.drop, "thresholds")
#attr(feature.drop, "thresholds")
#attr(mito.drop, "thresholds")

#sce_filtered <- sce[,!(libsize.drop | feature.drop | mito.drop)]
#data.frame(ByLibSize=sum(libsize.drop), ByLibSizeUpper=sum(libsize_u.drop), ByFeature=sum(feature.drop),ByMito=sum(mito.drop), Remaining=ncol(sce_filtered))

reasons <- quickPerCellQC(sce, percent_subsets=c("subsets_mito_percent"), batch=sce@colData@listData[["Experiment"]])
colSums(as.matrix(reasons))

attr(reasons@listData[["low_lib_size"]], "thresholds")
attr(reasons@listData[["low_n_features"]], "thresholds")
attr(reasons@listData[["high_subsets_mito_percent"]], "thresholds")

plotColData(sce, x="Experiment", y="total", colour_by=I(reasons@listData[["low_lib_size"]])) + scale_y_log10()
plotColData(sce, x="Experiment", y="detected", colour_by=I(reasons@listData[["low_n_features"]])) + scale_y_log10()
plotColData(sce, x="Experiment", y="percent.mito", colour_by=I(reasons@listData[["high_subsets_mito_percent"]]))
```
```{r}
sce$discard <- reasons$discard
gridExtra::grid.arrange(
    plotColData(sce, x="Experiment", y="sum", colour_by="discard")  + 
        scale_y_log10() + ggtitle("Total count"),
    plotColData(sce, x="Experiment", y="detected", colour_by="discard")  + 
        scale_y_log10() + ggtitle("Detected features"),
    plotColData(sce, x="Experiment", y="subsets_mito_percent", 
        colour_by="discard") + 
        ggtitle("Mito percent"),
    ncol=1
)
```

#### Before filtering
```{r}
VlnPlot(object = cow, features = c("nCount_RNA","nFeature_RNA"), pt.size = 0.1, group.by = c('Experiment'), ncol = 2, log = TRUE)
VlnPlot(object = cow, features = c("percent.mito", "percent.ribo"), pt.size = 0.1, group.by = c('Experiment'), ncol = 2)

FeatureScatter(cow, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = c('Experiment'))
FeatureScatter(cow, feature1 = "nFeature_RNA", feature2 = "percent.mito", group.by = c('Experiment'))
FeatureScatter(cow, feature1 = "nCount_RNA", feature2 = "percent.mito", group.by = c('Experiment'))
```

#### After filtering
```{r}
sce_filtered <- sce[,!reasons$discard]
cow_filtered <- as.Seurat(sce_filtered) #subset(cow, subset = nCount_RNA > 755 & nFeature_RNA > 2699 & percent.mito < 24)

VlnPlot(object = cow_filtered, features = c("nCount_RNA","nFeature_RNA"), pt.size = 0.1, group.by = c('Experiment'), ncol = 2, log = TRUE)
VlnPlot(object = cow_filtered, features = c("percent.mito", "percent.ribo"), pt.size = 0.1, group.by = c('Experiment'), ncol = 2)

FeatureScatter(cow_filtered, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = c('Experiment'))
FeatureScatter(cow_filtered, feature1 = "nFeature_RNA", feature2 = "percent.mito", group.by = c('Experiment'))
FeatureScatter(cow_filtered, feature1 = "nCount_RNA", feature2 = "percent.mito", group.by = c('Experiment'))
```

## Normalization {.tabset}

### Seruat LogNormalize
```{r}
cow_logNorm <- NormalizeData(object = cow_filtered, normalization.method = "LogNormalize", scale.factor = 10000)
cow_logNorm <- FindVariableFeatures(cow_logNorm, selection.method = "vst", nfeatures = 2000)
cow_logNorm <- ScaleData(object = cow_logNorm)
```

### Sctransform install_github("C3BI-pasteur-fr/UTechSCB-SCHNAPPs", dependencies = TRUE)
```{r, eval = FALSE}
cow_sct <- SCTransform(cow_filtered, verbose = FALSE)

saveRDS(cow_sct, file = "./cow_sct.rds")
```

### Scran
```{r}
library(scran)

set.seed(100)
clusters <- quickCluster(sce_filtered)
sce_scran <- computeSumFactors(sce_filtered, clusters=clusters)  
sce_scran <- logNormCounts(sce_scran)

dec <- modelGeneVar(sce_scran)
top.hvgs <- getTopHVGs(dec, n=2000)
```

## PCA {.tabset}

### (Seurat Log Normalize)
```{r}
cow_logNorm <- RunPCA(cow_logNorm, npcs = 30, verbose = FALSE)
cow_logNorm <- RunUMAP(cow_logNorm, reduction = "pca", dims = 1:30, verbose = FALSE)

DimPlot(cow_logNorm, reduction = "pca", group.by = "Experiment")

DimPlot(cow_logNorm, reduction = "umap", group.by = "Experiment")
DimPlot(cow_logNorm, reduction = "umap", group.by = "Cell_type", label = TRUE, repel = TRUE) + NoLegend()
```

### (Seurat SCT)
```{r, eval = FALSE}
cow_sct <- RunPCA(cow_sct, npcs = 30, verbose = FALSE)
cow_sct <- RunUMAP(cow_sct, reduction = "pca", dims = 1:30, verbose = FALSE)

DimPlot(cow_sct, reduction = "pca", group.by = "Experiment")

DimPlot(cow_sct, reduction = "umap", group.by = "Experiment")
DimPlot(cow_sct, reduction = "umap", group.by = "Cell_type", label = TRUE, repel = TRUE) + NoLegend()
```

### (Scran)
```{r}
sce_scran <- runPCA(sce_scran)
sce_scran <- runUMAP(sce_scran, dimred = 'PCA', n_dimred = 30)

plotReducedDim(sce_scran, dimred="PCA", colour_by="Experiment")
plotReducedDim(sce_scran, dimred="UMAP", colour_by="Experiment")
plotReducedDim(sce_scran, dimred="UMAP", colour_by="Cell_type")
```

## Integration {.tabset}
### (Seurat Log Normalize)
```{r}
cow_logNorm.list <- SplitObject(cow_logNorm, split.by = "Experiment")

for (i in 1:length(cow_logNorm.list)) {
    cow_logNorm.list[[i]] <- NormalizeData(cow_logNorm.list[[i]], verbose = FALSE)
    cow_logNorm.list[[i]] <- FindVariableFeatures(cow_logNorm.list[[i]], selection.method = "vst", nfeatures = 2000, 
        verbose = FALSE)
}

reference.list <- cow_logNorm.list[c("Exp1", "Exp2", "Exp3")]
k.filter <- min(200, sapply(cow_logNorm.list, ncol)) 
cow_logNorm.anchors <- FindIntegrationAnchors(object.list = reference.list, dims = 1:30, k.filter = k.filter)
cow_logNorm.integrated <- IntegrateData(anchorset = cow_logNorm.anchors, dims = 1:30)

DefaultAssay(cow_logNorm.integrated) <- "integrated"
cow_logNorm.integrated <- ScaleData(cow_logNorm.integrated, verbose = FALSE)
cow_logNorm.integrated <- RunPCA(cow_logNorm.integrated, npcs = 30, verbose = FALSE)
cow_logNorm.integrated <- RunUMAP(cow_logNorm.integrated, reduction = "pca", dims = 1:30)

DimPlot(cow_logNorm.integrated, reduction = "pca", group.by = "Experiment")

DimPlot(cow_logNorm.integrated, reduction = "umap", group.by = "Experiment")
DimPlot(cow_logNorm.integrated, reduction = "umap", group.by = "Cell_type", label = TRUE, repel = TRUE) + NoLegend()
```

### (Seurat SCT)
```{r, eval=FALSE}
cow_sct.list <- SplitObject(cow_filtered, split.by = "Experiment")

cow_sct.list <- cow_sct.list[c("Exp1", "Exp2", "Exp3")]
for (i in 1:length(cow_sct.list)) {
    cow_sct.list[[i]] <- SCTransform(cow_sct.list[[i]], verbose = FALSE)
}

saveRDS(cow_sct, file = "./cow_sct.rds")

cow_sct.features <- SelectIntegrationFeatures(object.list = cow_sct.list, nfeatures = 3000)
cow_sct.list <- PrepSCTIntegration(object.list = cow_sct.list, anchor.features = cow_sct.features, 
    verbose = FALSE)

cow_sct.anchors <- FindIntegrationAnchors(object.list = cow_sct.list, normalization.method = "SCT", 
    anchor.features = cow_sct.features, verbose = FALSE)
cow_sct.integrated <- IntegrateData(anchorset = cow_sct.anchors, normalization.method = "SCT", 
    verbose = FALSE)

cow_sct.integrated <- RunPCA(cow_sct.integrated, npcs = 30, verbose = FALSE)
cow_sct.integrated <- RunUMAP(cow_sct.integrated, reduction = "pca", dims = 1:30)

DimPlot(cow_sct.integrated, reduction = "pca", group.by = "Experiment")

DimPlot(cow_sct.integrated, reduction = "umap", group.by = "Experiment")
DimPlot(cow_sct.integrated, reduction = "umap", group.by = "Cell_type", label = TRUE, repel = TRUE) + NoLegend()
```

### (Scran)
```{r}
library(batchelor)
  
#rescaled <- rescaleBatches(sce_scran, batch=sce_scran$Experiment)

mnn_out <- fastMNN(sce_scran, batch=sce_scran$Experiment)
reducedDim(sce_scran, "MNN") <- reducedDim(mnn_out, "corrected")

sce_scran <- runPCA(sce_scran, dimred = 'MNN')
sce_scran <- runUMAP(sce_scran, dimred = 'PCA', n_dimred = 30)

plotReducedDim(sce_scran, dimred="PCA", colour_by="Experiment")
plotReducedDim(sce_scran, dimred="UMAP", colour_by="Experiment")
plotReducedDim(sce_scran, dimred="UMAP", colour_by="Cell_type")
```

## Determine PC
```{r}
DimHeatmap(cow_logNorm.integrated, dims = 1:9, cells = 500, balanced = TRUE)
DimHeatmap(cow_logNorm.integrated, dims = 10:18, cells = 500, balanced = TRUE)

cow_logNorm.integrated <- JackStraw(cow_logNorm.integrated, num.replicate = 100)
cow_logNorm.integrated <- ScoreJackStraw(cow_logNorm.integrated, dims = 1:20)
JackStrawPlot(cow_logNorm.integrated, dims = 1:20)
ElbowPlot(cow_logNorm.integrated)
```

## Clustering
```{r}
cow_logNorm.integrated <- FindNeighbors(cow_logNorm.integrated, dims = 1:14)
cow_logNorm.integrated <- FindClusters(cow_logNorm.integrated, resolution = 0.5)

cow_logNorm.integrated <- RunUMAP(cow_logNorm.integrated, dims = 1:14)
DimPlot(cow_logNorm.integrated, reduction = "umap")

cow_logNorm.integrated <- RunTSNE(object = cow_logNorm.integrated, dims.use = 1:14, do.fast = TRUE)
DimPlot(object = cow_logNorm.integrated, reduction = "tsne")
```

